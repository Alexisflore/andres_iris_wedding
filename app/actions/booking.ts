"use server"

import { supabase } from "@/lib/supabase"
import { revalidatePath } from "next/cache"

export async function createBooking(
  accommodationId: string,
  guestName: string,
  guestEmail: string,
  guestCount: number,
) {
  try {
    // V√©rifier si l'email existe d√©j√† dans les r√©servations
    const { data: existingBooking, error: checkError } = await supabase
      .from("bookings")
      .select(`
        *,
        accommodations (
          name,
          city,
          type
        )
      `)
      .eq("guest_email", guestEmail)
      .single()

    if (checkError && checkError.code !== "PGRST116") {
      // PGRST116 = no rows returned, ce qui est normal si l'email n'existe pas
      console.error("Error checking existing booking:", checkError)
      return { success: false, message: "Erreur lors de la v√©rification. Veuillez r√©essayer." }
    }

    // V√©rifier la capacit√© totale et les r√©servations existantes pour cet h√©bergement
    const { data: accommodation, error: fetchError } = await supabase
      .from("accommodations")
      .select("capacity")
      .eq("id", accommodationId)
      .single()

    if (fetchError || !accommodation) {
      return { success: false, message: "H√©bergement non trouv√©." }
    }

    // Calculer les r√©servations existantes pour cet h√©bergement
    const { data: existingBookings, error: bookingsError } = await supabase
      .from("bookings")
      .select("guest_count")
      .eq("accommodation_id", accommodationId)

    if (bookingsError) {
      console.error("Error fetching existing bookings:", bookingsError)
      return { success: false, message: "Erreur lors de la v√©rification de la disponibilit√©." }
    }

    // Calculer le total des r√©servations existantes
    const totalBooked = existingBookings?.reduce((total, booking) => total + booking.guest_count, 0) || 0
    const available = accommodation.capacity - totalBooked

    if (available < guestCount) {
      return { success: false, message: `Pas assez de places disponibles. Il reste ${available} place(s) disponible(s).` }
    }

    // Si l'email existe d√©j√†, retourner une r√©ponse sp√©ciale pour d√©clencher la modal
    if (existingBooking) {
      return {
        success: false,
        needsConfirmation: true,
        existingBooking,
        newData: {
          accommodationId,
          guestName,
          guestEmail,
          guestCount,
        },
        message: `Une information existe d√©j√† pour l'adresse ${guestEmail}. Souhaitez-vous la modifier ou ajouter une nouvelle information ?`
      }
    }

    // Cr√©er la r√©servation
    const { error: bookingError } = await supabase.from("bookings").insert({
      accommodation_id: accommodationId,
      guest_name: guestName,
      guest_email: guestEmail,
      guest_count: guestCount,
    })

    if (bookingError) {
      console.error("Error creating booking:", bookingError)
      return { success: false, message: "Erreur lors de l'enregistrement." }
    }

    revalidatePath("/accommodation")
    return { success: true, message: `Merci de nous avoir pr√©venu de votre r√©servation !` }
  } catch (error) {
    console.error("Unexpected error:", error)
    return { success: false, message: "Une erreur inattendue s'est produite." }
  }
}

export async function updateBooking(bookingId: string, newData: any) {
  try {
    // V√©rifier la capacit√© pour le nouvel h√©bergement
    const { data: accommodation, error: fetchError } = await supabase
      .from("accommodations")
      .select("capacity")
      .eq("id", newData.accommodationId)
      .single()

    if (fetchError || !accommodation) {
      return { success: false, message: "H√©bergement non trouv√©." }
    }

    // R√©cup√©rer la r√©servation existante pour conna√Ætre l'ancien nombre de personnes
    const { data: currentBooking, error: currentError } = await supabase
      .from("bookings")
      .select("guest_count, accommodation_id")
      .eq("id", bookingId)
      .single()

    if (currentError || !currentBooking) {
      return { success: false, message: "Information introuvable." }
    }

    // Calculer les r√©servations existantes pour le nouvel h√©bergement
    const { data: existingBookings, error: bookingsError } = await supabase
      .from("bookings")
      .select("guest_count")
      .eq("accommodation_id", newData.accommodationId)
      .neq("id", bookingId) // Exclure la r√©servation actuelle

    if (bookingsError) {
      console.error("Error fetching existing bookings:", bookingsError)
      return { success: false, message: "Erreur lors de la v√©rification de la disponibilit√©." }
    }

    // Calculer le total des r√©servations existantes
    const totalBooked = existingBookings?.reduce((total, booking) => total + booking.guest_count, 0) || 0
    const available = accommodation.capacity - totalBooked

    if (available < newData.guestCount) {
      return { success: false, message: `Pas assez de places disponibles. Il reste ${available} place(s) disponible(s).` }
    }

    // Mettre √† jour la r√©servation
    const { error: updateError } = await supabase
      .from("bookings")
      .update({
        accommodation_id: newData.accommodationId,
        guest_name: newData.guestName,
        guest_count: newData.guestCount,
      })
      .eq("id", bookingId)

    if (updateError) {
      console.error("Error updating booking:", updateError)
      return { success: false, message: "Erreur lors de la mise √† jour. Veuillez r√©essayer." }
    }

    revalidatePath("/accommodation")
    return {
      success: true,
      message: "Votre information a √©t√© mise √† jour avec succ√®s ! Merci de nous avoir pr√©venu.",
    }
  } catch (error) {
    console.error("Unexpected error:", error)
    return { success: false, message: "Une erreur inattendue s'est produite." }
  }
}

export async function forceCreateBooking(
  accommodationId: string,
  guestName: string,
  guestEmail: string,
  guestCount: number,
) {
  try {
    // V√©rifier la capacit√© totale et les r√©servations existantes pour cet h√©bergement
    const { data: accommodation, error: fetchError } = await supabase
      .from("accommodations")
      .select("capacity")
      .eq("id", accommodationId)
      .single()

    if (fetchError || !accommodation) {
      return { success: false, message: "H√©bergement non trouv√©." }
    }

    // Calculer les r√©servations existantes pour cet h√©bergement
    const { data: existingBookings, error: bookingsError } = await supabase
      .from("bookings")
      .select("guest_count")
      .eq("accommodation_id", accommodationId)

    if (bookingsError) {
      console.error("Error fetching existing bookings:", bookingsError)
      return { success: false, message: "Erreur lors de la v√©rification de la disponibilit√©." }
    }

    // Calculer le total des r√©servations existantes
    const totalBooked = existingBookings?.reduce((total, booking) => total + booking.guest_count, 0) || 0
    const available = accommodation.capacity - totalBooked

    if (available < guestCount) {
      return { success: false, message: `Pas assez de places disponibles. Il reste ${available} place(s) disponible(s).` }
    }

    // Cr√©er la nouvelle r√©servation (en for√ßant m√™me si l'email existe d√©j√†)
    const { error: bookingError } = await supabase.from("bookings").insert({
      accommodation_id: accommodationId,
      guest_name: guestName,
      guest_email: guestEmail,
      guest_count: guestCount,
    })

    if (bookingError) {
      console.error("Error creating booking:", bookingError)
      return { success: false, message: "Erreur lors de l'enregistrement." }
    }

    revalidatePath("/accommodation")
    return { success: true, message: `Merci de nous avoir pr√©venu de votre r√©servation de ${guestCount} personne(s) !` }
  } catch (error) {
    console.error("Unexpected error:", error)
    return { success: false, message: "Une erreur inattendue s'est produite." }
  }
}

export async function getAccommodations() {
  try {
    console.log("üîç Fetching accommodations from Supabase...")
    
    // R√©cup√©rer les h√©bergements
    const { data: accommodations, error } = await supabase
      .from("accommodations")
      .select("*")
      .order("distance")

    if (error) {
      console.error("‚ùå Error fetching accommodations:", error)
      return []
    }

    if (!accommodations || accommodations.length === 0) {
      console.log("‚ùå No accommodations found")
      return []
    }

    // R√©cup√©rer toutes les r√©servations pour calculer la disponibilit√©
    const { data: bookings, error: bookingsError } = await supabase
      .from("bookings")
      .select("accommodation_id, guest_count")

    if (bookingsError) {
      console.error("‚ùå Error fetching bookings:", bookingsError)
      // Retourner les accommodations sans mise √† jour de disponibilit√©
      return accommodations
    }

    // Calculer la disponibilit√© pour chaque h√©bergement
    const accommodationsWithAvailability = accommodations.map(accommodation => {
      // Calculer le total des r√©servations pour cet h√©bergement
      const totalBooked = bookings
        ?.filter(booking => booking.accommodation_id === accommodation.id)
        ?.reduce((total, booking) => total + booking.guest_count, 0) || 0

      // Calculer la disponibilit√©
      const available = Math.max(0, accommodation.capacity - totalBooked)

      console.log(`üè† ${accommodation.name}: ${available}/${accommodation.capacity} disponible (${totalBooked} r√©serv√©)`)

      return {
        ...accommodation,
        available
      }
    })

    console.log("‚úÖ Accommodations with calculated availability:", accommodationsWithAvailability.length)
    
    return accommodationsWithAvailability
  } catch (error) {
    console.error("üí• Unexpected error:", error)
    return []
  }
}

// Fonction de test pour v√©rifier les permissions d'√©criture
export async function testAccommodationInsert() {
  try {
    console.log("üß™ Testing accommodation insert capability...")
    
    const testAccommodation = {
      name: "Test Hotel",
      capacity: 4,
      address: "123 Test Street",
      city: "Test City",
      phone: "+33123456789",
      email: "test@hotel.com",
      distance: "5 km",
      type: "Hotel"
    }
    
    const { data, error } = await supabase
      .from("accommodations")
      .insert(testAccommodation)
      .select()
    
    if (error) {
      console.error("‚ùå Test insert failed:", error)
      return { success: false, error }
    } else {
      console.log("‚úÖ Test insert successful:", data)
      
      // Supprimer le test
      if (data && data.length > 0) {
        const deleteResult = await supabase
          .from("accommodations")
          .delete()
          .eq("id", data[0].id)
        console.log("üóëÔ∏è Test data cleanup:", deleteResult)
      }
      
      return { success: true, data }
    }
  } catch (error) {
    console.error("üí• Test insert error:", error)
    return { success: false, error }
  }
}
